package main.visitor;

import main.ast.nodes.*;
import main.ast.nodes.DirectDeclarator.ArrayDeclarator;
import main.ast.nodes.DirectDeclarator.FunctionDeclarator;
import main.ast.nodes.DirectDeclarator.IdentifierDeclarator;
import main.ast.nodes.DirectDeclarator.NestedDeclarator;
import main.ast.nodes.Expr.*;
import main.ast.nodes.Expr.operator.UnaryOperator;
import main.ast.nodes.Stmt.*;
import main.ast.nodes.ExternalDeclaration.*;
import main.symbolTable.SymbolTable;
import main.symbolTable.exceptions.ItemNotFoundException;
import main.symbolTable.item.FuncDecSymbolTableItem;
import main.symbolTable.item.VarDecSymbolTableItem;
import main.typeErrors.ArgumentTypeMismatch;
import main.typeErrors.NonSameOperands;
import main.typeErrors.ReturnTypeMismatch;
import main.typeErrors.TypeError;
import main.types.*;

import java.lang.reflect.Array;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashSet;
import java.util.List;
import java.util.Objects;
import java.util.Set;

public class TypeChecker extends Visitor<Type> {
    private SymbolTable globalSym;
    private  SymbolTable symTab;
    private  Set<Integer> errorLines = new HashSet<>();
    private  List<TypeError> errors = new ArrayList<>();
    /** Tracks the current function's declared return type */
    private Type currentFunctionReturnType;

    private void addError(TypeError error) {
        if (!errorLines.contains(error.getLine())) {
            errors.add(error);
            errorLines.add(error.getLine());
        }
    }

    public TypeChecker() {
    }
    public static String getWithoutPointer(String input) {
        int starIndex = input.indexOf('*');
        if (starIndex == -1) {
            return input;
        } else {
            return input.substring(0, starIndex);
        }
    }

    private Type getTypeFromString(String typeStr) {
        typeStr = getWithoutPointer(typeStr);
        switch (typeStr.toLowerCase()) {
            case "int":
            case "signed":
                return new IntType();
            case "char": return new CharType();
            case "void": return new VoidType();
            case "double": return new DoubleType();
            case "string": return new StringType();
            case "boolean": return new BooleanType();
            case "float": return new FloatType();
            case "short": return new ShortType();
            default: return new NonType();
        }
    }


    // --- Entry point for a function declaration ---
    @Override
    public Type visit(Program program){
        globalSym = program.getSymbol_table();
        symTab = program.getSymbol_table();
        program.getTranslationUnit().accept(this);

        for(TypeError er : errors){
            System.out.println(er.getMessage());
        }
        return null;
    }

    @Override
    public Type visit(TranslationUnit translationUnit){
        for(ExternalDeclaration ext : translationUnit.getExternalDeclarations()){
            if(ext != null)
                ext.accept(this);
        }
        return null;
    }

    @Override
    public Type visit(DecExtDec declaration){
        Type l = new NonType();
        Type r = new NonType();
        String op = "=";
//        System.out.println("--------------------Declaration of line: "+declaration.getLine());
        // Assignment =, +=, etc.
        if(declaration.getInitDeclaratorList()!=null){
            if(declaration.getInitDeclaratorList().getInitDeclarators().size()==1){
                if(declaration.getInitDeclaratorList().getInitDeclarators().get(0).getDeclarator()!=null) {
                    if (declaration.getInitDeclaratorList().getInitDeclarators().get(0).getDeclarator().getDirectDeclarator() instanceof IdentifierDeclarator) {
                        String idenName = ((IdentifierDeclarator) declaration.getInitDeclaratorList().getInitDeclarators().get(0).getDeclarator().getDirectDeclarator()).getName();
                        try {
                            VarDecSymbolTableItem v = (VarDecSymbolTableItem)
                                    symTab.getItem(VarDecSymbolTableItem.START_KEY + idenName);
//                            System.out.println("Left: "+idenName+" / "+v.getVarType());
                            l = getTypeFromString(v.getVarType());
                        } catch (ItemNotFoundException e) {
                            return new NonType();
                        }
                    }
                }
                //
                if(declaration.getInitDeclaratorList().getInitDeclarators().get(0).getInitializer()!=null) {
                    if(declaration.getInitDeclaratorList().getInitDeclarators().get(0).getInitializer().getExpr()!=null) {
                        Expr rightExpr = declaration.getInitDeclaratorList().getInitDeclarators().get(0).getInitializer().getExpr();
                        r = declaration.getInitDeclaratorList().getInitDeclarators().get(0).getInitializer().getExpr().accept(this);
                        if(rightExpr instanceof FunctionCallExpr){
                            List<String> builtInFunctions = Arrays.asList(
                                    "getc", "stdin", "stdout", "printf", "scanf", "gets", "puts",
                                    "getchar", "putchar", "strlen", "strcpy", "strncpy", "strcat",
                                    "strcmp", "strchr", "strstr", "malloc", "calloc", "realloc",
                                    "free", "exit", "atoi", "atof", "abs", "fopen", "fclose",
                                    "fread", "fwrite", "fseek", "ftell", "fprintf", "fscanf",
                                    "perror", "system", "time", "clock", "rand", "srand"
                            );

                            String funcName = "";
                            if((((FunctionCallExpr) rightExpr).getExpr() != null) && (((FunctionCallExpr) rightExpr).getExpr() instanceof Identifier)) {
                                funcName = ((Identifier) ((FunctionCallExpr) rightExpr).getExpr()).getName();
                            }

                            if (builtInFunctions.contains(funcName)) {
                                r = getTypeFromString(l.toString());
                            }
                        }
//                        System.out.println("Right: " + r.toString());
                        
                        // Check if the right side is a binary expression and handle its type correctly
                        if (declaration.getInitDeclaratorList().getInitDeclarators().get(0).getInitializer().getExpr() instanceof BinaryExpr) {
                            BinaryExpr b = (BinaryExpr) declaration.getInitDeclaratorList().getInitDeclarators().get(0).getInitializer().getExpr();
                            Type leftOp = b.getFirstOperand().accept(this);
                            Type rightOp = b.getSecondOperand().accept(this);
                            if (leftOp instanceof IntType && rightOp instanceof IntType) {
                                r = new IntType();
                            }
                        }
                    }
                }
                if (isAssignmentOperator(op)) {
                    if (!TypeUtils.isAssignable(l, r)) {
                        addError(new NonSameOperands(declaration.getLine()));
                        return new NonType();
                    }
                    return l;
                }
                //triggering an error
                addError(new NonSameOperands(declaration.getLine()));
                return new NonType();
            }
        }
        return null;
    }

    @Override
    public Type visit(FuncDefExtDec fd) {
        symTab = fd.getSymbol_table();
        // Record the declared return type
        if (fd.getDeclarationSpecifiers() != null) {
            String typeStr = fd.getDeclarationSpecifiers().getDeclarationSpecifiers().get(0).getName();
            currentFunctionReturnType = getTypeFromString(typeStr);
        } else {
            // Default return type in C
            currentFunctionReturnType = new IntType();
        }

        // Then type-check the body:
        if (fd.getCompoundStatement() != null) {
            fd.getCompoundStatement().accept(this);
        }
        // clear after leaving
        currentFunctionReturnType = null;
        return null;
    }

    // --- Return statement ---
    @Override
    public Type visit(JumpStatement ret) {
        Type exprType = new NonType();
        if(ret.getReturnExpr() != null) {
            exprType = ret.getReturnExpr().accept(this);
        }
//        System.out.println("Return: "+ exprType.toString());
        // Compare to the function's declared return type
        if (currentFunctionReturnType != null && exprType != null) {
            if (!TypeUtils.isAssignable(currentFunctionReturnType, exprType)) {
                addError(new ReturnTypeMismatch(ret.getLine()));
            }
        }
        return null;
    }

    // --- Literals & identifiers just return their declared types ---

    @Override
    public Type visit(DeclarationSpecifiers declarationSpecifiers) {
        return null;
    }

    @Override
    public Type visit(Declarator declarator) {
        return null;
    }

    @Override
    public Type visit(DeclarationList declarationList) {
        return null;
    }

    @Override
    public Type visit(CompoundStatement compoundStatement) {
        for(BlockItem bl : compoundStatement.getBlocks())
        {
            if(bl != null) {
                if (bl.getDeclaration() != null)
                    bl.getDeclaration().accept(this);
                else if(bl.getStatement() != null)
                    bl.getStatement().accept(this);
            }
        }
        return null;
    }

    @Override
    public Type visit(Identifier id) {
        try {
            VarDecSymbolTableItem v = (VarDecSymbolTableItem)
                    symTab.getItem(VarDecSymbolTableItem.START_KEY + id.getName());
//            System.out.println(id.getName()+ " FOUND IN LINE "+ id.getLine()+ " AS "+ v.getVarType());
            return getTypeFromString(v.getVarType());
        } catch (ItemNotFoundException e) {
            return new NonType();
        }
    }


    public static boolean isFloat(String s) {
        try {
            Float.parseFloat(s);
            // reject things like "123" if you only want "true" floats:
            return s.contains(".") || s.toLowerCase().contains("e");
        } catch (NumberFormatException e) {
            return false;
        }
    }

    // All other AST nodes you can leave un-implemented or return nul
    @Override
    public Type visit(Constant constant) {
        String val = constant.getConstantValue();
        if (val.contains(".") || val.toLowerCase().contains("e")) {
            // treat all non-integer literals as double
            return new FloatType();
        }
        return new IntType();
    }

    public ArrayList<Type> numOfArgsCalculator(CommaExpr commaExpr) {
        ArrayList<Type> argTypes = new ArrayList<>();

        // We iterate through all expressions in the CommaExpr
        for (Expr expr : commaExpr.getExpressions()) {
            // If the expression is an instance of CommaExpr, it means there's a nested argument list
            if (expr instanceof CommaExpr) {
                argTypes.addAll(numOfArgsCalculator((CommaExpr) expr));  // Recursively count arguments in the nested CommaExpr
            } else {
                argTypes.add(expr.accept(this));
            }
        }

        return argTypes;
    }

    @Override
    public Type visit(FunctionCallExpr call) {
        List<String> builtInFunctions = Arrays.asList(
            "getc", "stdin", "stdout", "printf", "scanf", "gets", "puts",
            "getchar", "putchar", "strlen", "strcpy", "strncpy", "strcat",
            "strcmp", "strchr", "strstr", "malloc", "calloc", "realloc",
            "free", "exit", "atoi", "atof", "abs", "fopen", "fclose",
            "fread", "fwrite", "fseek", "ftell", "fprintf", "fscanf",
            "perror", "system", "time", "clock", "rand", "srand"
        );

        String funcName = "";
        if((call.getExpr() != null) && (call.getExpr() instanceof Identifier)) {
            funcName = ((Identifier) call.getExpr()).getName();
        }

        if (builtInFunctions.contains(funcName)) {
            return new NonType();
        }

        try {
            FuncDecSymbolTableItem funcDec = (FuncDecSymbolTableItem) globalSym.getItem(
                FuncDecSymbolTableItem.START_KEY + funcName + "-" + call.getNumOfArgs());
            ArrayList<String> declaredTypes = funcDec.getArgTypes();
//            System.out.println("-------line"+ call.getLine()+"-----------");
            if (call.getArgumentExpressionList() != null) {
                ArrayList<Type> argTypes = new ArrayList<>();
                if (call.getArgumentExpressionList() != null) {
                    // Check if the argument expression list has a single constant (e.g., StringLiteral)
                    if (call.getArgumentExpressionList().getExpressions().size() == 1){
//                        argTypes.add(call.getArgumentExpressionList().getExpressions().get(0).accept(this));
                        argTypes = numOfArgsCalculator(call.getArgumentExpressionList());
                    } else {
                        // Otherwise, use numOfArgsCalculator to recursively count all arguments
                        argTypes = numOfArgsCalculator(call.getArgumentExpressionList());
                    }
                }
//                System.out.println("Function call types are: ");
//                for (Type t : argTypes){
//                    if(t!=null)
//                        System.out.println(t.toString());
//                }
//                System.out.println("Function arg types are: ");
//                for (String t : funcDec.getArgTypes()){
//                    System.out.println(t.toString());
//                }
                for (int i = 0; i < argTypes.size(); i++) {
                    Type paramType = getTypeFromString(getWithoutPointer(declaredTypes.get(i)));
                    if (!TypeUtils.isAssignable(paramType, argTypes.get(i))) {
                        addError(new ArgumentTypeMismatch(call.getLine()));
                        return new NonType();
                    }
                }
            }
            return getTypeFromString(funcDec.getReturnType());
        } catch (ItemNotFoundException ex) {
            return new NonType();
        }
    }


    @Override
    public Type visit(UnaryExpr u) {
        Type t = u.getOperand().accept(this);
        UnaryOperator op = UnaryOperator.valueOf(u.getOperator());

        switch (op) {
            case Plus:
            case Minus:
            case PlusPlus:
            case MinusMinus:
                if (!TypeUtils.isArithmetic(t)) {
                    addError(new NonSameOperands(u.getLine()));
                    return new NonType();
                }
                // unary +/-, ++/-- preserve type
                return t;

            case Not: // !
                if (!(t instanceof BooleanType)) {
                    addError(new NonSameOperands(u.getLine()));
                }
                return new BooleanType();

            case Tilda: // ~
                if (!TypeUtils.isInteger(t)) {
                    addError(new NonSameOperands(u.getLine()));
                }
                return t;

            default:
                addError(new NonSameOperands(u.getLine()));
                return new NonType();
        }
    }

    @Override
    public Type visit(TernaryExpr ternaryExpr) {
        Type thenType = ternaryExpr.getThenExpr().accept(this);
        Type elseType = ternaryExpr.getElseExpr().accept(this);

        return thenType;
    }

    @Override
    public Type visit(CommaExpr commaExpr) {
        for(Expr expr : commaExpr.getExpressions()){
            if(expr != null)
                expr.accept(this);
        }
        return null;
    }

    @Override
    public Type visit(AssignmentExpr assignmentExpr){
        Type l = assignmentExpr.getLeftExpr().accept(this);
        Type r = assignmentExpr.getRightExpr().accept(this);
//        System.out.println("first: "+l.toString());
//        System.out.println("second: "+r.toString());
        String op = assignmentExpr.getOperator();

        // Assignment =, +=, etc.
        if (isAssignmentOperator(op)) {
            if (!TypeUtils.isAssignable(l, r)) {
                addError(new NonSameOperands(assignmentExpr.getLine()));
                return new NonType();
            }
            return l;
        }

        addError(new NonSameOperands(assignmentExpr.getLine()));
        return new NonType();
    }

    @Override
    public Type visit(DeclarationSpecifier declarationSpecifier) {
        return null;
    }

    @Override
    public Type visit(Pointer pointer) {
        return null;
    }

    @Override
    public Type visit(NestedDeclarator nestedDeclarator) {
        return null;
    }

    @Override
    public String visit(IdentifierDeclarator identifierDeclarator) {
        return "";
    }

    @Override
    public Type visit(ArrayDeclarator arrayDeclarator) {
        return null;
    }

    @Override
    public Type visit(FunctionDeclarator functionDeclarator) {
        return null;
    }

    @Override
    public Type visit(ParameterList parameterList) {
        return null;
    }

    @Override
    public Type visit(ParameterDeclaration parameterDeclaration) {
        return null;
    }

    @Override
    public Type visit(IdentifierList identifierList) {
        return null;
    }

    @Override
    public Type visit(BlockItem blockItem) {
        return null;
    }

    @Override
    public Type visit(AbstractDeclarator abstractDeclarator) {
        return null;
    }

    @Override
    public Type visit(DirectAbstractDeclarator directAbstractDeclarator) {
        return null;
    }

    @Override
    public Type visit(StringLiteral stringLiteral) {
        return new StringType();
    }

    @Override
    public Type visit(SpecifierQualifierList specifierQualifierList) {
        return null;
    }

    @Override
    public Type visit(ExpressionStatement expressionStatement) {
        if(expressionStatement.getExprStmt() != null)
            expressionStatement.getExprStmt().accept(this);
        return null;
    }

    @Override
    public Type visit(IterationStatement iterationStatement) {
        if(iterationStatement.getStatement() != null) {
            symTab = iterationStatement.getSymbol_table();
            iterationStatement.getStatement().accept(this);
        }
        return null;
    }

    @Override
    public Type visit(ForCondition forCondition) {
        return null;
    }

    @Override
    public Type visit(ForExpr forExpr) {
        return null;
    }

    @Override
    public Type visit(ForDeclaration forDeclaration) {
        return null;
    }

    @Override
    public Type visit(InitDeclaratorList initDeclaratorList) {
        return null;
    }

    @Override
    public Type visit(InitDeclarator initDeclarator) {
        return null;
    }

    @Override
    public Type visit(Initializer initializer) {
        return null;
    }

    @Override
    public Type visit(DesignationInitializerTuple designationInitializerTuple) {
        return null;
    }

    @Override
    public Type visit(InitializerList initializerList) {
        return null;
    }

    @Override
    public Type visit(Designation designation) {
        return null;
    }

    @Override
    public Type visit(Designator designator) {
        return null;
    }

    @Override
    public Type visit(TypeName typeName) {
        return null;
    }

    @Override
    public Type visit(CompoundLiteralExpr compoundLiteralExpr) {
        if (compoundLiteralExpr.getInitializerList() != null) {
            compoundLiteralExpr.getInitializerList().accept(this);
        }
        return null;
    }

    @Override
    public Type visit(ArrayIndexingExpr arrayIndexingExpr) {
        if(arrayIndexingExpr.getArrayExpr() != null)
            arrayIndexingExpr.getArrayExpr().accept(this);
        if(arrayIndexingExpr.getIndexExpr() != null)
            arrayIndexingExpr.getIndexExpr().accept(this);
        return null;
    }

    public Boolean isArithmeticOperator(String operator){
        return (Objects.equals(operator, "+")||
                Objects.equals(operator, "*")||
                Objects.equals(operator, "-")||
                Objects.equals(operator, "/")||
                Objects.equals(operator, "%"));
    }
    public Boolean isBitwiseOperator(String operator){
        return (Objects.equals(operator, "&")||
                Objects.equals(operator, "|")||
                Objects.equals(operator, "^")||
                Objects.equals(operator, "&&")||
                Objects.equals(operator, "||"));
    }
    public Boolean isShiftOperator(String operator){
        return (Objects.equals(operator, ">>")||
                Objects.equals(operator, "<<"));
    }
    public Boolean isRelationalOperator(String operator){
        return Objects.equals(operator, "<")||
                Objects.equals(operator, ">")||
                Objects.equals(operator, "<=")||
                Objects.equals(operator, ">=");
    }

    public Boolean isEqualityOperator(String operator) {
        return Objects.equals(operator, "==") ||
                Objects.equals(operator, "!=");
    }

    public Boolean isAssignmentOperator(String operator){
        return Objects.equals(operator, "=") ||
                Objects.equals(operator, "+=") ||
                Objects.equals(operator, "-=") ||
                Objects.equals(operator, "*=") ||
                Objects.equals(operator, "/=") ||
                Objects.equals(operator, "%=");
    }

    // === Binary ===
    @Override
    public Type visit(BinaryExpr b) {
        Type l = b.getFirstOperand().accept(this);
        Type r = b.getSecondOperand().accept(this);
        String op = b.getOperator();
//        System.out.println("-----------------------------------Binary line "+ b.getLine());
//        System.out.println("first op : "+ l.toString());
//        System.out.println("second op : "+ r.toString());

        // Arithmetic  + - * / %
        if (isArithmeticOperator(op)) {
            if (!TypeUtils.isArithmetic(l) || !TypeUtils.isArithmetic(r)) {
                addError(new NonSameOperands(b.getLine()));
                return new NonType();
            }
            // apply C99 usual arithmetic conversions:
            Type resultType = TypeUtils.usualArithmeticConversion(l, r);
            if (resultType == null) {
                addError(new NonSameOperands(b.getLine()));
                return new NonType();
            }
            return resultType;
        }

        // Bitwise  & | ^
        if (isBitwiseOperator(op)) {
            if (!TypeUtils.isInteger(l) || !TypeUtils.isInteger(r)) {
                addError(new NonSameOperands(b.getLine()));
                return new NonType();
            }
            return TypeUtils.usualArithmeticConversion(l, r);
        }

        // Shifts << >>
        if (isShiftOperator(op)) {
            if (!TypeUtils.isInteger(l) || !TypeUtils.isInteger(r)) {
                addError(new NonSameOperands(b.getLine()));
                return new NonType();
            }
            // result is the promoted type of left operand
            return TypeUtils.usualArithmeticConversion(l, r);
        }

        // Relational < <= > >=
        if (isRelationalOperator(op)) {
            if (!TypeUtils.isArithmetic(l) || !TypeUtils.isArithmetic(r)) {
                addError(new NonSameOperands(b.getLine()));
                return new NonType();
            }
            return new BooleanType();
        }

        // Equality == !=
        if (isEqualityOperator(op)) {
            if (!TypeUtils.areComparableForEquality(l, r)) {
                addError(new NonSameOperands(b.getLine()));
                return new NonType();
            }
            return new BooleanType();
        }

        // fallback
        addError(new NonSameOperands(b.getLine()));
        return new NonType();
    }


    // === Cast & Ternary ===
    @Override
    public Type visit(CastExpr c) {
        if(c.getType() != null){
            if(c.getType().getSpecifierQualifierList() != null){
                if(c.getType().getSpecifierQualifierList().getTypeSpecifier()!=null)
                    return getTypeFromString(c.getType().getSpecifierQualifierList().getTypeSpecifier().getType());
            }
        }

        return null;
    }

    @Override
    public Type visit(PrefixUnaryExpr prefixUnaryExpr) {
        if(prefixUnaryExpr.getOperand()!=null)
            prefixUnaryExpr.getOperand().accept(this);
        return null;
    }

    @Override
    public Type visit(SizeOfExpr sizeOfExpr) {
//        System.out.println("SIZE OF");
        if(sizeOfExpr.getType()!=null){
            if(sizeOfExpr.getType().getSpecifierQualifierList()!=null)
            {
                if(sizeOfExpr.getType().getSpecifierQualifierList().getTypeSpecifier()!=null)
                {
                    return getTypeFromString(sizeOfExpr.getType().getSpecifierQualifierList().getTypeSpecifier().getType());
                }
            }
        }
        return new NonType();
    }

    @Override
    public Type visit(TypeSpecifier typeSpecifier) {
        return null;
    }

    @Override
    public Type visit(SelectionStatement selectionStatement) {
        if(selectionStatement.getThenStmt() instanceof CompoundStatement co1)
        {
            symTab = selectionStatement.getIfSymbolTable();
            if(co1 != null)
            {
                co1.accept(this);
            }
        }
        for (int i = 0; i < selectionStatement.getElseIfThenStmts().size(); i++) {
            Stmt stmt = selectionStatement.getElseIfThenStmts().get(i);
            if (stmt instanceof CompoundStatement co2) {
                symTab = selectionStatement.getElseIfSymbolTables().get(i);
                if (co2 != null) {
                    co2.accept(this);
                }
            }
        }
        if(selectionStatement.getElseStmt() instanceof CompoundStatement co3)
        {
            if(co3 != null)
            {
                symTab = selectionStatement.getElseSymbolTale();
                co3.accept(this);
            }
        }return null;
    }
}
