package main.visitor;

import main.ast.nodes.*;
import main.ast.nodes.DirectDeclarator.ArrayDeclarator;
import main.ast.nodes.DirectDeclarator.FunctionDeclarator;
import main.ast.nodes.DirectDeclarator.IdentifierDeclarator;
import main.ast.nodes.DirectDeclarator.NestedDeclarator;
import main.ast.nodes.Expr.*;
import main.ast.nodes.ExternalDeclaration.DecExtDec;
import main.ast.nodes.ExternalDeclaration.ExternalDeclaration;
import main.ast.nodes.ExternalDeclaration.FuncDefExtDec;
import main.ast.nodes.Stmt.*;
import main.symbolTable.SymbolTable;
import main.symbolTable.exceptions.ItemAlreadyExistsException;
import main.symbolTable.exceptions.ItemNotFoundException;
import main.symbolTable.item.FuncDecSymbolTableItem;
import main.symbolTable.item.SymbolTableItem;
import main.symbolTable.item.VarDecSymbolTableItem;
import main.vulnerabilityErrors.UninitializedVariable;
import main.vulnerabilityErrors.VulnerabilityError;

import java.util.*;

/*GOALs:
 *   1. this is for setting symbol table
 * */

public class NameAnalyser extends Visitor<Void>{
    private ArrayList<VulnerabilityError> vulnerabilityErrors = new ArrayList<>();
    private List<AbstractMap.SimpleEntry<Integer, String>> errorsForRemovingDup = new ArrayList<>();

    public ArrayList<VulnerabilityError> getVulnerabilityErrors() {
        return vulnerabilityErrors;
    }
    int inArguments = 0;
    ArrayList<String> unusedVariables = new ArrayList<>();
    ArrayList<String> DeclaredFunctions = new ArrayList<>();
    String tempFuncNames;
    int tempDecLine;
    int state = 0;
    String tempType;
    String pointerLevel;
    private FuncDefExtDec main;
    private int mainNumOfArgs = 0;
    String arrayType;
    private Boolean Error = Boolean.FALSE;
    String tempReturnType;
    ArrayList<String> tempArgTypes = new ArrayList<>();
    List<String> builtInFunctions = Arrays.asList(
                    "getc" ,
                    "stdin",
                    "stdout",
                    "printf",
                    "scanf",
                    "gets",
                    "puts",
                    "getchar",
                    "putchar",
                    "strlen",
                    "strcpy",
                    "strncpy",
                    "strcat",
                    "strcmp",
                    "strchr",
                    "strstr",
                    "malloc",
                    "calloc",
                    "realloc",
                    "free",
                    "exit",
                    "atoi",
                    "atof",
                    "abs",
                    "fopen",
                    "fclose",
                    "fread",
                    "fwrite",
                    "fseek",
                    "ftell",
                    "fprintf",
                    "fscanf",
                    "perror",
                    "system",
                    "time",
                    "clock",
                    "rand",
                    "srand"
    );

    public Boolean getError() {
        return Error;
    }

    public void setError(Boolean error) {
        Error = error;
    }

    public void updateUnusedVariables(SymbolTable topSymbolTable){
        for (Map.Entry<String, SymbolTableItem> entry : topSymbolTable.items.entrySet()) {
            SymbolTableItem item = entry.getValue();
            if (item instanceof VarDecSymbolTableItem) {
                VarDecSymbolTableItem varItem = (VarDecSymbolTableItem) item;
                if(varItem.getUsed() == 0){
                    unusedVariables.add(varItem.getVarName() + "&" + varItem.getLine());
                }
            }
        }
    }

    public int getMainNumOfArgs() {
        return mainNumOfArgs;
    }


    public ArrayList<String> getDeclaredFunctions() {
        return DeclaredFunctions;
    }

    public FuncDefExtDec getMain() {
        return this.main;
    }

    public ArrayList<String> getUnusedVariables(){
        return unusedVariables;
    }

    public void makingErrorObjects(){
        for (AbstractMap.SimpleEntry<Integer, String> tempError : errorsForRemovingDup) {
            int idLine = tempError.getKey();
            String idName = tempError.getValue();
            vulnerabilityErrors.add(new UninitializedVariable(idLine, idName));
        }
    }

    @Override
    public Void visit(Program program) {
        SymbolTable.top = new SymbolTable();
        SymbolTable.root = SymbolTable.top;

        program.setSymbol_table(SymbolTable.top);
        program.getTranslationUnit().accept(this);

        //for making objects of error by removing duplications
        makingErrorObjects();
        return null;
    }

    @Override
    public Void visit(TranslationUnit translationUnit){
        for(ExternalDeclaration ext : translationUnit.getExternalDeclarations()){
            if(ext != null)
                ext.accept(this);
        }
        return null;
    }

    @Override
    public Void visit(FuncDefExtDec funcDefExtDec) {
        int numOfArgs = 0;
        state = 0;
        //setting return type
        if(funcDefExtDec.getDeclarationSpecifiers() != null){
            if(funcDefExtDec.getDeclarationSpecifiers().getDeclarationSpecifiers() != null)
                tempReturnType = funcDefExtDec.getDeclarationSpecifiers().getDeclarationSpecifiers().get(0).getName();
        }

        if(funcDefExtDec.getDeclarator().getDirectDeclarator() instanceof FunctionDeclarator) {
            funcDefExtDec.getDeclarator().getDirectDeclarator().accept(this);
            if(((FunctionDeclarator) funcDefExtDec.getDeclarator().getDirectDeclarator()).getParameterList() != null)
                numOfArgs = ((FunctionDeclarator) funcDefExtDec.getDeclarator().getDirectDeclarator()).getParameterList().getParameters().size();
        }

        if(Objects.equals(tempFuncNames, "main")) {
            this.main = funcDefExtDec;
            this.mainNumOfArgs = numOfArgs;
        }
        funcDefExtDec.setNumOfArgs(numOfArgs);
        state = 1;
        FuncDecSymbolTableItem func_dec_item = new FuncDecSymbolTableItem(funcDefExtDec, tempFuncNames, numOfArgs);
        //setting function name in its ast object
        funcDefExtDec.setFuncName(tempFuncNames);
        //setting return type of the function definition symbol table item
        func_dec_item.setReturnType(tempReturnType);

        //setting arguments of the function
        if(funcDefExtDec.getDeclarator() != null){
            if((funcDefExtDec.getDeclarator().getDirectDeclarator()!= null)&&(funcDefExtDec.getDeclarator().getDirectDeclarator() instanceof FunctionDeclarator)){
                if(((FunctionDeclarator) funcDefExtDec.getDeclarator().getDirectDeclarator()).getParameterList()!=null){
                    if(((FunctionDeclarator) funcDefExtDec.getDeclarator().getDirectDeclarator()).getParameterList().getParameters()!=null) {
                        setTempArgumnetTypes(((FunctionDeclarator) funcDefExtDec.getDeclarator().getDirectDeclarator()).getParameterList().getParameters());
                        func_dec_item.setArgTypes(tempArgTypes);
                    }
                }
            }
        }
        //making temp variables for signiture oof functions clear
        tempReturnType = null;
        tempArgTypes.clear();

        try {
            SymbolTable.top.put(func_dec_item);
            this.DeclaredFunctions.add(tempFuncNames+"-"+numOfArgs);
        } catch (ItemAlreadyExistsException e) {
            System.out.println("Redefinition of function \"" + tempFuncNames +"\" in line " + funcDefExtDec.getLine());
            setError(Boolean.TRUE);
        }

        SymbolTable func_dec_symbol_table = new SymbolTable(SymbolTable.top);
        funcDefExtDec.setSymbol_table(func_dec_symbol_table);
        SymbolTable.push(func_dec_symbol_table);

        //visit declarator(parameters)
        inArguments = 1;
        if(funcDefExtDec.getDeclarator() != null)
            funcDefExtDec.getDeclarator().accept(this);
        inArguments = 0;

        //visit declarationList
        if(funcDefExtDec.getDeclarationList() != null)
            funcDefExtDec.getDeclarationList().accept(this);

        //visit compoundStmt
        if(funcDefExtDec.getCompoundStatement() != null)
            funcDefExtDec.getCompoundStatement().accept(this);


        updateUnusedVariables(SymbolTable.top);
        SymbolTable.pop();
        return null;
    }

    @Override
    public Void visit(TypeSpecifier typeSpecifier) {
        return null;
    }

    @Override
    public Void visit(DeclarationSpecifiers declarationSpecifiers) {
        if(declarationSpecifiers.getDeclarationSpecifiers() != null)
        {
            if(declarationSpecifiers.getDeclarationSpecifiers().size() == 2) {
                String varType = declarationSpecifiers.getDeclarationSpecifiers().get(0).getName();
                String varName = declarationSpecifiers.getDeclarationSpecifiers().get(1).getName();
                VarDecSymbolTableItem var_dec_item = new VarDecSymbolTableItem(varType, varName, declarationSpecifiers.getLine());
                if(inArguments != 0)
                    var_dec_item.setInitialized(1);
                try {
                    SymbolTable.top.put(var_dec_item);
//                    System.out.println("Variable "+ varType + " "+ varName + " declared in line "+ declarationSpecifiers.getLine());
                } catch (ItemAlreadyExistsException e) {
                    System.out.println("Redeclaration of variable \"" + varName + "\" in line " + declarationSpecifiers.getLine());
                    setError(Boolean.TRUE);
                }
            }
        }
        return null;
    }

    public ArrayList<String> fetchNewVariables(InitDeclaratorList initDeclaratorList){
        ArrayList<String> newVars = new ArrayList<>();
        for(InitDeclarator init : initDeclaratorList.getInitDeclarators()){
            if((init.getDeclarator() != null) && (init.getDeclarator().getDirectDeclarator() instanceof IdentifierDeclarator)){
                String newVar = ((IdentifierDeclarator) init.getDeclarator().getDirectDeclarator()).getName();
                newVars.add(newVar);
            }
            if((init.getDeclarator() != null) && (init.getDeclarator().getDirectDeclarator() instanceof ArrayDeclarator)){
                if(((ArrayDeclarator) init.getDeclarator().getDirectDeclarator()).getBaseDeclarator() instanceof IdentifierDeclarator) {
                    String newVar = ((IdentifierDeclarator) ((ArrayDeclarator) init.getDeclarator().getDirectDeclarator()).getBaseDeclarator()).getName();
                    if(((ArrayDeclarator) init.getDeclarator().getDirectDeclarator()).getExpr() != null)
                        newVar += "{";
                    newVars.add(newVar);
                }
            }
        }
        return newVars;
    }

    public void addNewVarDeclarations(String varType, ArrayList<String> varNames, int line){
        for(String newVarName : varNames) {
            int isArray = 0;
            if (!newVarName.isEmpty() && newVarName.charAt(newVarName.length() - 1) == '{') {
                newVarName = newVarName.substring(0, newVarName.length() - 1);
                isArray = 1;
            }
            VarDecSymbolTableItem var_dec_item = new VarDecSymbolTableItem(varType, newVarName, line);
            var_dec_item.setInitialized(1);
            if(isArray == 1)
                var_dec_item.setIsArray(1);
            try {
                SymbolTable.top.put(var_dec_item);
            } catch (ItemAlreadyExistsException e) {
                System.out.println("Redeclaration of variable \"" + newVarName + "\" in line " + line);
                setError(Boolean.TRUE);
            }
        }
    }

    @Override
    public Void visit(DecExtDec declaration){
        if(declaration.getDeclarationSpecifiers() != null) {
            declaration.getDeclarationSpecifiers().accept(this);
            if(declaration.getDeclarationSpecifiers().getDeclarationSpecifiers() != null)
                tempType = declaration.getDeclarationSpecifiers().getDeclarationSpecifiers().get(0).getName();
        }
        ArrayList<String> newVariables = new ArrayList<>();
        if(declaration.getInitDeclaratorList() != null)
        {
            String pointerLevelH = "";
            newVariables = fetchNewVariables(declaration.getInitDeclaratorList());
            if(declaration.getInitDeclaratorList() != null){
                if(declaration.getInitDeclaratorList().getInitDeclarators() != null){
                   if(declaration.getInitDeclaratorList().getInitDeclarators().get(0).getDeclarator() != null){
                       if(declaration.getInitDeclaratorList().getInitDeclarators().get(0).getDeclarator().getPointer() != null)
                           pointerLevelH = declaration.getInitDeclaratorList().getInitDeclarators().get(0).getDeclarator().getPointer().pointerMaker();
                   }

                }
            }
            int line = declaration.getDeclarationSpecifiers().getLine();
            if(pointerLevelH != "")
                tempType += pointerLevelH;
            addNewVarDeclarations(tempType, newVariables, line);
            declaration.getInitDeclaratorList().accept(this);
        }
        return null;
    }

    @Override
    public Void visit(Declarator declarator) {
        declarator.getDirectDeclarator().accept(this);
        return null;
    }

    @Override
    public Void visit(DeclarationList declarationList) {
        for(DecExtDec dec : declarationList.getDeclarations()){
            if(dec != null)
                dec.accept(this);
        }
        return null;
    }

    @Override
    public Void visit(BlockItem blockItem){
        return null;
    }

    @Override
    public Void visit(CompoundStatement compoundStatement) {
        for(BlockItem bl : compoundStatement.getBlocks())
        {
            if(bl != null) {
                if (bl.getDeclaration() != null)
                    bl.getDeclaration().accept(this);
                else if(bl.getStatement() != null)
                    bl.getStatement().accept(this);
            }
        }
        return null;
    }

    @Override
    public Void visit(Identifier identifier){
        // First check if it's a built-in identifier
        if (builtInFunctions.contains(identifier.getName())) {
            return null;
        }

        try {
            String key = VarDecSymbolTableItem.START_KEY + identifier.getName();
            SymbolTableItem item = SymbolTable.top.getItem(key);

            if (item instanceof VarDecSymbolTableItem) {
                VarDecSymbolTableItem varItem = (VarDecSymbolTableItem) item;
                varItem.setUsed(1);
            }
        } catch (ItemNotFoundException e) {
            System.out.println("Line:" + identifier.getLine() + "-> " + identifier.getName() + " not declared");
            setError(Boolean.TRUE);
        }
        return null;
    }

    @Override
    public Void visit(Constant constant) {
        return null;
    }

    @Override
    public Void visit(BinaryExpr binaryExpr) {
        firstCheck(binaryExpr.getFirstOperand());
        firstCheck(binaryExpr.getSecondOperand());
        
        binaryExpr.getFirstOperand().accept(this);
        binaryExpr.getSecondOperand().accept(this);

        return null;
    }

    @Override
    public Void visit(UnaryExpr unaryExpr) {
        firstCheck(unaryExpr.getOperand());
        unaryExpr.getOperand().accept(this);
        return null;
    }

    @Override
    public Void visit(TernaryExpr ternaryExpr) {
        firstCheck(ternaryExpr.getCondition());
        firstCheck(ternaryExpr.getThenExpr());
        firstCheck(ternaryExpr.getElseExpr());
        
        
        ternaryExpr.getCondition().accept(this);
        ternaryExpr.getThenExpr().accept(this);
        ternaryExpr.getElseExpr().accept(this);
        return null;
    }

    @Override
    public Void visit(CommaExpr commaExpr) {
        for(Expr expr : commaExpr.getExpressions()){
            if(expr != null)
                firstCheck(expr);
                expr.accept(this);
        }
        return null;
    }

    public void setInitialization(Expr expr) {
        try {
            if(expr instanceof Identifier) {
                VarDecSymbolTableItem varItem = (VarDecSymbolTableItem) SymbolTable.top.getItem(VarDecSymbolTableItem.START_KEY + ((Identifier) expr).getName());
                if (varItem != null) {
                    varItem.setInitialized(1);
                }
            }
        }
        catch (ItemNotFoundException e) {
            setError(Boolean.TRUE);
        }
    }

    public static void addIfNotExists(List<AbstractMap.SimpleEntry<Integer, String>> list, AbstractMap.SimpleEntry<Integer, String> newEntry) {
        boolean exists = list.stream()
                .anyMatch(entry -> entry.getKey().equals(newEntry.getKey()) &&
                        entry.getValue().equals(newEntry.getValue()));
        if (!exists) {
            list.add(newEntry);
        }
    }

    public void firstCheck(Expr expr){
        if(expr instanceof FunctionCallExpr){
            FunctionCallExpr funcCall = (FunctionCallExpr) expr;
            // For scanf calls, we've already handled initialization in visit(FunctionCallExpr)
            if (funcCall.getExpr() instanceof Identifier && 
                ((Identifier)funcCall.getExpr()).getName().equals("scanf")) {
                return;
            }
            funcCall.accept(this);
        }
        else if(expr instanceof Identifier) {
            checkForUninitializedUsed((Identifier) expr);
        }
        else if(expr instanceof BinaryExpr){
            firstCheck(((BinaryExpr) expr).getFirstOperand());
            firstCheck(((BinaryExpr) expr).getSecondOperand());
        }
        else if(expr instanceof UnaryExpr) {
            UnaryExpr unaryExpr = (UnaryExpr) expr;
            if (!unaryExpr.getOperator().equals("&")) {
                firstCheck(unaryExpr.getOperand());
            }
        }
        else if(expr instanceof TernaryExpr){
            firstCheck(((TernaryExpr) expr).getCondition());
            firstCheck(((TernaryExpr) expr).getThenExpr());
            firstCheck(((TernaryExpr) expr).getElseExpr());
        }
        else if(expr instanceof CommaExpr){
            for(Expr e: ((CommaExpr) expr).getExpressions())
                firstCheck(e);
        }
        else if(expr instanceof CastExpr)
            firstCheck(((CastExpr) expr).getExpr());
        else if(expr instanceof PrefixUnaryExpr)
            firstCheck(((PrefixUnaryExpr) expr).getOperand());
        else
            return;
    }
    
    @Override
    public Void visit(AssignmentExpr assignmentExpr) {
        // Handle getc case in assignment
        if (assignmentExpr.getRightExpr() instanceof FunctionCallExpr) {
            FunctionCallExpr funcCall = (FunctionCallExpr) assignmentExpr.getRightExpr();
            if (funcCall.getExpr() instanceof Identifier) {
                String funcName = ((Identifier) funcCall.getExpr()).getName();
                if (funcName.equals("getc") && assignmentExpr.getLeftExpr() instanceof Identifier) {
                    String varName = ((Identifier) assignmentExpr.getLeftExpr()).getName();
                    try {
                        String key = VarDecSymbolTableItem.START_KEY + varName;
                        VarDecSymbolTableItem varItem = (VarDecSymbolTableItem) SymbolTable.top.getItem(key);
                        varItem.setInitialized(1);
                        varItem.setIsInput(1);
                    } catch (ItemNotFoundException ignored) {
                    }
                }
            }
        }

        setInitialization(assignmentExpr.getLeftExpr());
        firstCheck(assignmentExpr.getRightExpr());
        if (assignmentExpr.getRightExpr() != null) {
            assignmentExpr.getRightExpr().accept(this);
        }
        assignmentExpr.getLeftExpr().accept(this);
        return null;
    }


    @Override
    public Void visit(DeclarationSpecifier declarationSpecifier) {
        if(declarationSpecifier != null)
            tempType = declarationSpecifier.getName();
        return null;
    }

    @Override
    public Void visit(Pointer pointer) {
        return null;
    }

    @Override
    public Void visit(NestedDeclarator nestedDeclarator) {
        nestedDeclarator.getInnerDeclarator().accept(this);
        return null;
    }

    @Override
    public String visit(IdentifierDeclarator identifierDeclarator) {
        tempFuncNames = identifierDeclarator.getName();
        return null;
    }

    @Override
    public Void visit(ArrayDeclarator arrayDeclarator) {
//        System.out.println("This is for Array declaration");
        if(arrayDeclarator.getBaseDeclarator() != null)
            arrayDeclarator.getBaseDeclarator().accept(this);
        if(arrayDeclarator.getExpr() != null)
            arrayDeclarator.getExpr().accept(this);
        return null;
    }

    @Override
    public Void visit(FunctionDeclarator functionDeclarator) {
        if(state == 0) {
            if (functionDeclarator.getBaseDirectDeclarator() instanceof IdentifierDeclarator)
                tempFuncNames = ((IdentifierDeclarator) functionDeclarator.getBaseDirectDeclarator()).getName();
        }
        else {
            if(functionDeclarator.getParameterList() != null) {
                functionDeclarator.getParameterList().accept(this);
            }
        }
        return null;
    }

    public void setTempArgumnetTypes(ArrayList<ParameterDeclaration> parameters){
        for(ParameterDeclaration par : parameters){
            if(par.getSpecifiers() != null){
                if(par.getSpecifiers().getDeclarationSpecifiers() != null){
                    if(par.getSpecifiers().getDeclarationSpecifiers().size() == 1){
                        String subType = par.getSpecifiers().getDeclarationSpecifiers().get(0).getName();
                        if(par.getDeclarator() != null){
                            if(par.getDeclarator().getPointer() != null){
                                subType += par.getDeclarator().getPointer().pointerMaker();
                            }
                        }
                        tempArgTypes.add(subType);
                    }
                    else if(par.getSpecifiers().getDeclarationSpecifiers().size() == 2){
                        tempArgTypes.add(par.getSpecifiers().getDeclarationSpecifiers().get(0).getName());
                    }
                }
            }
        }
    }

    @Override
    public Void visit(ParameterList parameterList) {
        for(ParameterDeclaration par : parameterList.getParameters())
        {
            if(par != null)
                par.accept(this);
        }
        return null;
    }

    public void checkForArrayDeclaration(Declarator declarator, String type){
        String pointerLevel = "";
        if(declarator.getPointer() != null)
            pointerLevel = declarator.getPointer().pointerMaker();
        if((declarator.getDirectDeclarator() != null) && (declarator.getDirectDeclarator() instanceof ArrayDeclarator)){
            if((((ArrayDeclarator) declarator.getDirectDeclarator()).getBaseDeclarator() != null) && (((ArrayDeclarator) declarator.getDirectDeclarator()).getBaseDeclarator() instanceof IdentifierDeclarator)){
                String varName = ((IdentifierDeclarator) ((ArrayDeclarator) declarator.getDirectDeclarator()).getBaseDeclarator()).getName();
                int varLine = ((IdentifierDeclarator) ((ArrayDeclarator) declarator.getDirectDeclarator()).getBaseDeclarator()).getLine();
                if(pointerLevel != null)
                    type += pointerLevel;
                VarDecSymbolTableItem var_dec_item = new VarDecSymbolTableItem(type, varName, varLine);
                try {
                    SymbolTable.top.put(var_dec_item);
//                    System.out.println("Variable "+ varType + " "+ varName + " declared in line "+ declarationSpecifiers.getLine());
                } catch (ItemAlreadyExistsException e) {
                    System.out.println("Redeclaration of variable \"" + varName + "\" in line " + varLine);
                    setError(Boolean.TRUE);
                }
            }
        }
    }

    public String fetchingTypeOfVariable(DeclarationSpecifiers dec){
        String varType = "";
        if(dec.getDeclarationSpecifiers() != null) {
            varType = dec.getDeclarationSpecifiers().get(0).getName();
        }
        return varType;
    }

    @Override
    public Void visit(ParameterDeclaration parameterDeclaration) {
        if(parameterDeclaration.getSpecifiers() != null)
            parameterDeclaration.getSpecifiers().accept(this);
        if(parameterDeclaration.getDeclarator() != null) {
            parameterDeclaration.getDeclarator().accept(this);
            String currType = fetchingTypeOfVariable(parameterDeclaration.getSpecifiers());
            checkForArrayDeclaration(parameterDeclaration.getDeclarator(), currType);

            // Mark argv as input
            if (parameterDeclaration.getDeclarator().getDirectDeclarator() instanceof IdentifierDeclarator) {
                if(parameterDeclaration.getDeclarator().getPointer() != null)
                    currType += parameterDeclaration.getDeclarator().getPointer().pointerMaker();
                String varName = ((IdentifierDeclarator) parameterDeclaration.getDeclarator().getDirectDeclarator()).getName();
                if(pointerLevel != null)
                    currType += pointerLevel;
                VarDecSymbolTableItem var_dec_item = new VarDecSymbolTableItem(currType , varName, parameterDeclaration.getDeclarator().getDirectDeclarator().getLine());
                var_dec_item.setInitialized(1);
                try {
                    SymbolTable.top.put(var_dec_item);
//                    System.out.println("Variable "+ varType + " "+ varName + " declared in line "+ declarationSpecifiers.getLine());
                } catch (ItemAlreadyExistsException e) {
                    System.out.println("Redeclaration of variable \"" + varName + "\" in line " + parameterDeclaration.getDeclarator().getDirectDeclarator().getLine());
                    setError(Boolean.TRUE);
                }
//                }
//                try {
//                        String key = VarDecSymbolTableItem.START_KEY + paramName;
//                        VarDecSymbolTableItem varItem = (VarDecSymbolTableItem) SymbolTable.top.getItem(key);
//                        if (paramName.equals("argv"))
//                            varItem.setIsInput(1);
//                } catch (ItemNotFoundException ignored) {}
            }
        }
        return null;
    }

    @Override
    public Void visit(IdentifierList identifierList) {
        for(Identifier id : identifierList.getIdentifiers()){
            if(id != null)
                id.accept(this);
        }
        return null;
    }

    @Override
    public Void visit(AbstractDeclarator abstractDeclarator) {
        return null;
    }

    @Override
    public Void visit(DirectAbstractDeclarator directAbstractDeclarator) {
        return null;
    }

    @Override
    public Void visit(StringLiteral stringLiteral) {
        return null;
    }

    @Override
    public Void visit(SpecifierQualifierList specifierQualifierList) {
        return null;
    }

    @Override
    public Void visit(IterationStatement iterationStatement) {
        SymbolTable symbolTable = new SymbolTable(SymbolTable.top);
        iterationStatement.setSymbol_table(symbolTable);
        SymbolTable.push(symbolTable);

        //visit expr and stmt
        if(iterationStatement.getCondition() != null)
            iterationStatement.getCondition().accept(this);
        if(iterationStatement.getForCondition() != null)
            iterationStatement.getForCondition().accept(this);
        if(iterationStatement.getStatement() != null)
            iterationStatement.getStatement().accept(this);

        updateUnusedVariables(SymbolTable.top);
        SymbolTable.pop();
        return null;
    }

    @Override
    public Void visit(ExpressionStatement expressionStatement) {
        if(expressionStatement.getExprStmt() != null)
            expressionStatement.getExprStmt().accept(this);
        return null;
    }

    @Override
    public Void visit(SelectionStatement selectionStatement) {
        SymbolTable symbolTable = new SymbolTable(SymbolTable.top);
        selectionStatement.setIfSymbolTable(symbolTable);
        SymbolTable.push(symbolTable);

        //visit if
        selectionStatement.getCondition().accept(this);
        selectionStatement.getThenStmt().accept(this);

        updateUnusedVariables(SymbolTable.top);
        SymbolTable.pop();

        //visit else if
        for (int i = 0; i < selectionStatement.getElseIfThenStmts().size(); i++) {
            SymbolTable symbolTable1 = new SymbolTable(SymbolTable.top);
            selectionStatement.addElseIfSymbolTable(symbolTable1);
            SymbolTable.push(symbolTable1);

            Stmt stmt = selectionStatement.getElseIfThenStmts().get(i);
            if(stmt != null)
                stmt.accept(this);

            updateUnusedVariables(SymbolTable.top);
            SymbolTable.pop();
        }

        SymbolTable symbolTable2 = new SymbolTable(SymbolTable.top);
        selectionStatement.setElseSymbolTale(symbolTable2);
        SymbolTable.push(symbolTable2);

        //visit else
        if(selectionStatement.getElseStmt() != null)
            selectionStatement.getElseStmt().accept(this);


        updateUnusedVariables(SymbolTable.top);
        SymbolTable.pop();


        return null;
    }

    @Override
    public Void visit(ForCondition forCondition) {
        if(forCondition.getForDeclaration() != null)
            forCondition.getForDeclaration().accept(this);
        if(forCondition.getInitExpression() != null)
            forCondition.getInitExpression().accept(this);
        return null;
    }

    @Override
    public Void visit(ForExpr forExpr) {
        for(Expr newExpr : forExpr.getExpressions()){
            if(newExpr != null)
                newExpr.accept(this);
        }
        return null;
    }

    @Override
    public Void visit(ForDeclaration forDeclaration) {
        if(forDeclaration.getDeclarationSpecifiers() != null)
            forDeclaration.getDeclarationSpecifiers().accept(this);
        ArrayList<String> newVariables = new ArrayList<>();
        if(forDeclaration.getInitDeclaratorList() != null)
        {
            newVariables = fetchNewVariables(forDeclaration.getInitDeclaratorList());
            int line = forDeclaration.getDeclarationSpecifiers().getLine();
            addNewVarDeclarations(tempType, newVariables, line);
        }
        return null;
    }

    @Override
    public Void visit(InitDeclaratorList initDeclaratorList) {
        for(InitDeclarator init : initDeclaratorList.getInitDeclarators())
        {
            if(init != null)
            {
                init.accept(this);
            }
        }
        return null;
    }

    @Override
    public Void visit(InitDeclarator initDeclarator) {
        if(initDeclarator.getDeclarator() != null)
            initDeclarator.getDeclarator().accept(this);
        if(initDeclarator.getInitializer() != null)
            initDeclarator.getInitializer().accept(this);
        return null;
    }

    @Override
    public Void visit(Initializer initializer) {
        if(initializer.getInitializerList() != null)
            initializer.getInitializerList().accept(this);
        if(initializer.getExpr() != null)
            firstCheck(initializer.getExpr());
            initializer.getExpr().accept(this);
        return null;
    }

    @Override
    public Void visit(DesignationInitializerTuple designationInitializerTuple) {
        return null;
    }

    @Override
    public Void visit(InitializerList initializerList) {
        return null;
    }

    @Override
    public Void visit(Designation designation) {
        return null;
    }

    @Override
    public Void visit(Designator designator) {
        return null;
    }

    @Override
    public Void visit(JumpStatement jumpStatement) {
        if(jumpStatement.getReturnExpr() != null)
            jumpStatement.getReturnExpr().accept(this);
        return null;
    }

    @Override
    public Void visit(TypeName typeName) {
        return null;
    }

    @Override
    public Void visit(CompoundLiteralExpr compoundLiteralExpr) {
        if (compoundLiteralExpr.getInitializerList() != null) {
            compoundLiteralExpr.getInitializerList().accept(this);
        }
        return null;
    }


    @Override
    public Void visit(ArrayIndexingExpr arrayIndexingExpr) {
        if(arrayIndexingExpr.getArrayExpr() != null)
            arrayIndexingExpr.getArrayExpr().accept(this);
        if(arrayIndexingExpr.getIndexExpr() != null)
            arrayIndexingExpr.getIndexExpr().accept(this);
        return null;
    }

    public int numOfArgsCalculator(CommaExpr commaExpr) {
        int numOfArgs = 0;

        // We iterate through all expressions in the CommaExpr
        for (Expr expr : commaExpr.getExpressions()) {
            // If the expression is an instance of CommaExpr, it means there's a nested argument list
            if (expr instanceof CommaExpr) {
                numOfArgs += numOfArgsCalculator((CommaExpr) expr);  // Recursively count arguments in the nested CommaExpr
            } else {
                // If it's a single expression (e.g., Constant, StringLiteral, etc.), count it as one argument
                numOfArgs += 1;
            }
        }

        return numOfArgs;
    }

    private List<Expr> extractAllArguments(Expr expr) {
        List<Expr> args = new ArrayList<>();
        if (expr instanceof CommaExpr) {
            CommaExpr commaExpr = (CommaExpr) expr;
            for (Expr e : commaExpr.getExpressions()) {
                args.addAll(extractAllArguments(e));
            }
        } else {
            args.add(expr);
        }
        return args;
    }

    private boolean isAddressOfOperation(Expr expr) {
        if (expr instanceof UnaryExpr) {
            UnaryExpr unaryExpr = (UnaryExpr) expr;
            return unaryExpr.getOperator().equals("&");
        } else if (expr instanceof PrefixUnaryExpr) {
            PrefixUnaryExpr prefixUnaryExpr = (PrefixUnaryExpr) expr;
            // First check if this PrefixUnaryExpr has the & operator
            for (String op : prefixUnaryExpr.getPrefixOperators()) {
                if (op.equals("&")) {
                    return true;
                }
            }
            // If not, check its operand recursively
            return isAddressOfOperation(prefixUnaryExpr.getOperand());
        }
        return false;
    }

    private Identifier findIdentifierOperand(Expr expr) {
        if (expr instanceof Identifier) {
            return (Identifier) expr;
        } else if (expr instanceof UnaryExpr) {
            return findIdentifierOperand(((UnaryExpr) expr).getOperand());
        } else if (expr instanceof PrefixUnaryExpr) {
            return findIdentifierOperand(((PrefixUnaryExpr) expr).getOperand());
        }
        return null;
    }

    @Override
    public Void visit(FunctionCallExpr functionCallExpr) {
        String curName = ((Identifier)((functionCallExpr).getExpr())).getName();
        functionCallExpr.setName(curName);
        
        // Handle scanf initialization BEFORE checking arguments
        if (curName.equals("scanf") && functionCallExpr.getArgumentExpressionList() != null) {
            // Extract all arguments by recursively traversing CommaExpr structures
            List<Expr> allArgs = extractAllArguments(functionCallExpr.getArgumentExpressionList());
            
            // Skip first arg (format string) and process remaining args
            for (int i = 1; i < allArgs.size(); i++) {
                Expr arg = allArgs.get(i);
                boolean isAddressOf = isAddressOfOperation(arg);
                if (isAddressOf) {
                    Identifier iden = findIdentifierOperand(arg);
                    if (iden != null) {
                        String varName = iden.getName();
                        
                        try {
                            String key = VarDecSymbolTableItem.START_KEY + varName;
                            VarDecSymbolTableItem varItem = (VarDecSymbolTableItem) SymbolTable.top.getItem(key);
                            varItem.setInitialized(1);
                            varItem.setIsInput(1);
                        } catch (ItemNotFoundException e) {
                        }
                    }
                }
            }
            
            // For scanf, only check first argument (format string)
            if (!allArgs.isEmpty()) {
                allArgs.get(0).accept(this);
            }
            return null;  // Return here to avoid processing arguments again
        }

        // For non-scanf functions, proceed with normal processing
        int numOfArgs = 0;
        functionCallExpr.setNumOfArgs(numOfArgs);
        if (functionCallExpr.getArgumentExpressionList() != null) {
            if ((functionCallExpr.getArgumentExpressionList() instanceof CommaExpr) &&
                (((CommaExpr)functionCallExpr.getArgumentExpressionList()).getExpressions().size() == 1) &&
                (((CommaExpr)functionCallExpr.getArgumentExpressionList()).getExpressions().get(0) instanceof Constant)) {
                numOfArgs = 1;
                functionCallExpr.setNumOfArgs(numOfArgs);
            } else {
                numOfArgs = numOfArgsCalculator(functionCallExpr.getArgumentExpressionList());
                functionCallExpr.setNumOfArgs(numOfArgs);
            }
            functionCallExpr.getArgumentExpressionList().accept(this);
        }

        try {
            if (!builtInFunctions.contains(curName)) {
                SymbolTable.top.getItem(FuncDecSymbolTableItem.START_KEY + curName+"-"+numOfArgs);
            }
        } catch (ItemNotFoundException e) {
            System.out.println("Line:" + functionCallExpr.getLine() + "-> " + curName + " not declared");
            setError(Boolean.TRUE);
        }
        return null;
    }

    @Override
    public Void visit(CastExpr castExpr) {
        firstCheck(castExpr);
        if (castExpr.getExpr() != null) {
            castExpr.getExpr().accept(this);
        }
        return null;
    }


    @Override
    public Void visit(PrefixUnaryExpr prefixUnaryExpr) {
        firstCheck(prefixUnaryExpr);
        if(prefixUnaryExpr.getOperand() != null)
            prefixUnaryExpr.getOperand().accept(this);
        return null;
    }

    @Override
    public Void visit(SizeOfExpr sizeOfExpr) {
        return null;
    }

    public void checkForUninitializedUsed(Identifier iden) {
        if (builtInFunctions.contains(iden.getName())) {
            return;
        }

        try {
            String key = VarDecSymbolTableItem.START_KEY + iden.getName();
            VarDecSymbolTableItem varItem = (VarDecSymbolTableItem) SymbolTable.top.getItem(key);
            
            if (varItem.getInitialized() != 1) {
                addIfNotExists(errorsForRemovingDup, new AbstractMap.SimpleEntry<>(iden.getLine(), iden.getName()));
            }
        } catch (ItemNotFoundException e) {
            setError(Boolean.TRUE);
        }
    }
}


