package main.visitor;

import main.ast.nodes.*;
import main.ast.nodes.DirectDeclarator.*;
import main.ast.nodes.Expr.*;
import main.ast.nodes.ExternalDeclaration.*;
import main.ast.nodes.Stmt.*;
import main.symbolTable.SymbolTable;
import main.vulnerabilityErrors.*;
import java.util.*;

public class MemoryLeakAnalyzer extends Visitor<Void> {
    private final ArrayList<VulnerabilityError> vulnerabilityErrors;
    private Map<String, Integer> allocatedMemory;
    private Set<String> deallocatedMemory;
    private String currentDeclaringVariable;
    private int currentDeclarationLine;

    public MemoryLeakAnalyzer() {
        this.vulnerabilityErrors = new ArrayList<>();
        this.allocatedMemory = new HashMap<>();
        this.deallocatedMemory = new HashSet<>();
        this.currentDeclaringVariable = null;
        this.currentDeclarationLine = 0;
    }

    public ArrayList<VulnerabilityError> getVulnerabilityErrors() {
        return vulnerabilityErrors;
    }

    @Override
    public Void visit(Program program) {
        if (program.getTranslationUnit() != null) {
            program.getTranslationUnit().accept(this);
        }

        // Check for memory leaks at program end
        for (Map.Entry<String, Integer> entry : allocatedMemory.entrySet()) {
            String varName = entry.getKey();
            int line = entry.getValue();
            if (!deallocatedMemory.contains(varName)) {
                vulnerabilityErrors.add(new MemoryNotDeallocated(line, varName));
            }
        }
        return null;
    }

    @Override
    public Void visit(TranslationUnit translationUnit) {
        for (ExternalDeclaration externalDeclaration : translationUnit.getExternalDeclarations()) {
            if (externalDeclaration != null) {
                externalDeclaration.accept(this);
            }
        }
        return null;
    }

    @Override
    public Void visit(FuncDefExtDec funcDefExtDec) {
        // Save current scope
        Map<String, Integer> previousAllocatedMemory = new HashMap<>(allocatedMemory);
        Set<String> previousDeallocatedMemory = new HashSet<>(deallocatedMemory);
        
        // Clear for new function scope
        allocatedMemory.clear();
        deallocatedMemory.clear();

        // Process function body
        if (funcDefExtDec.getCompoundStatement() != null) {
            funcDefExtDec.getCompoundStatement().accept(this);
        }

        // Check for memory leaks in function scope
        for (Map.Entry<String, Integer> entry : allocatedMemory.entrySet()) {
            String varName = entry.getKey();
            int line = entry.getValue();
            if (!deallocatedMemory.contains(varName)) {
                vulnerabilityErrors.add(new MemoryNotDeallocated(line, varName));
            }
        }

        // Restore previous scope
        allocatedMemory = previousAllocatedMemory;
        deallocatedMemory = previousDeallocatedMemory;
        
        return null;
    }

    @Override
    public Void visit(CompoundStatement compoundStatement) {
        for (BlockItem bl : compoundStatement.getBlocks()) {
            if (bl != null) {
                if (bl.getDeclaration() != null) {
                    bl.getDeclaration().accept(this);
                } else if (bl.getStatement() != null) {
                    bl.getStatement().accept(this);
                }
            }
        }
        return null;
    }

    @Override
    public Void visit(DecExtDec declaration) {
        if (declaration.getInitDeclaratorList() != null) {
            declaration.getInitDeclaratorList().accept(this);
        }
        return null;
    }

    @Override
    public Void visit(InitDeclaratorList initDeclaratorList) {
        for (InitDeclarator initDeclarator : initDeclaratorList.getInitDeclarators()) {
            if (initDeclarator != null) {
                initDeclarator.accept(this);
            }
        }
        return null;
    }

    @Override
    public Void visit(InitDeclarator initDeclarator) {
        if (initDeclarator.getDeclarator() != null) {
            if (initDeclarator.getDeclarator().getDirectDeclarator() instanceof IdentifierDeclarator) {
                currentDeclaringVariable = ((IdentifierDeclarator) initDeclarator.getDeclarator()
                        .getDirectDeclarator())
                        .getName();
                currentDeclarationLine = initDeclarator.getLine();
            }
            else if (initDeclarator.getDeclarator().getDirectDeclarator() instanceof ArrayDeclarator) {
                ArrayDeclarator arrayDecl = (ArrayDeclarator) initDeclarator.getDeclarator().getDirectDeclarator();
                if (arrayDecl.getBaseDeclarator() instanceof IdentifierDeclarator) {
                    currentDeclaringVariable = ((IdentifierDeclarator) arrayDecl.getBaseDeclarator()).getName();
                    currentDeclarationLine = initDeclarator.getLine();
                }
            }
        }
        
        if (initDeclarator.getInitializer() != null) {
            initDeclarator.getInitializer().accept(this);
        }
        
        currentDeclaringVariable = null;
        currentDeclarationLine = 0;
        return null;
    }

    @Override
    public Void visit(Initializer initializer) {
        if (initializer.getExpr() != null) {
            if (initializer.getExpr() instanceof FunctionCallExpr) {
                FunctionCallExpr functionCall = (FunctionCallExpr) initializer.getExpr();
                if (functionCall.getExpr() instanceof Identifier) {
                    String funcName = ((Identifier) functionCall.getExpr()).getName();
                    if (funcName.equals("malloc") && currentDeclaringVariable != null) {
                        allocatedMemory.put(currentDeclaringVariable, functionCall.getLine());
                    }
                }
            }
            initializer.getExpr().accept(this);
        }
        return null;
    }

    @Override
    public Void visit(ExpressionStatement expressionStatement) {
        if (expressionStatement.getExprStmt() != null) {
            expressionStatement.getExprStmt().accept(this);
        }
        return null;
    }

    @Override
    public Void visit(AssignmentExpr assignmentExpr) {
        if (assignmentExpr.getRightExpr() != null) {
            assignmentExpr.getRightExpr().accept(this);
        }

        if (assignmentExpr.getRightExpr() instanceof FunctionCallExpr) {
            FunctionCallExpr functionCall = (FunctionCallExpr) assignmentExpr.getRightExpr();
            if (functionCall.getExpr() instanceof Identifier) {
                String funcName = ((Identifier) functionCall.getExpr()).getName();
                if (funcName.equals("malloc") && assignmentExpr.getLeftExpr() instanceof Identifier) {
                    String varName = ((Identifier) assignmentExpr.getLeftExpr()).getName();
                    allocatedMemory.put(varName, functionCall.getLine());
                }
            }
        }

        return null;
    }

    @Override
    public Void visit(FunctionCallExpr functionCall) {
        if (functionCall.getExpr() instanceof Identifier) {
            String funcName = ((Identifier) functionCall.getExpr()).getName();
            if (funcName.equals("free") || (funcName.equals("cleanup"))) {
                handleFreeCall(functionCall);
            }
        }

        if (functionCall.getArgumentExpressionList() != null) {
            for (Expr arg : functionCall.getArgumentExpressionList().getExpressions()) {
                if (arg != null) {
                    arg.accept(this);
                }
            }
        }
        return null;
    }

    private void handleFreeCall(FunctionCallExpr freeCall) {
        if (freeCall.getArgumentExpressionList() != null &&
            !freeCall.getArgumentExpressionList().getExpressions().isEmpty()) {
            
            Expr freeArg = freeCall.getArgumentExpressionList().getExpressions().get(0);
            if (freeArg instanceof Identifier) {
                String varName = ((Identifier) freeArg).getName();
                deallocatedMemory.add(varName);
                allocatedMemory.remove(varName);
            }
        }
    }

    @Override public Void visit(Constant constant) { return null; }
    @Override public Void visit(BinaryExpr binaryExpr) { return null; }
    @Override public Void visit(UnaryExpr unaryExpr) { return null; }
    @Override public Void visit(TernaryExpr ternaryExpr) { return null; }
    @Override public Void visit(CommaExpr commaExpr) { return null; }
    @Override public Void visit(DeclarationSpecifier declarationSpecifier) { return null; }
    @Override public Void visit(Pointer pointer) { return null; }
    @Override public Void visit(NestedDeclarator nestedDeclarator) { return null; }
    @Override public String visit(IdentifierDeclarator identifierDeclarator) { return ""; }
    @Override public Void visit(ArrayDeclarator arrayDeclarator) { return null; }
    @Override public Void visit(FunctionDeclarator functionDeclarator) { return null; }
    @Override public Void visit(ParameterList parameterList) { return null; }
    @Override public Void visit(ParameterDeclaration parameterDeclaration) { return null; }
    @Override public Void visit(IdentifierList identifierList) { return null; }
    @Override public Void visit(BlockItem blockItem) { return null; }
    @Override public Void visit(AbstractDeclarator abstractDeclarator) { return null; }
    @Override public Void visit(DirectAbstractDeclarator directAbstractDeclarator) { return null; }
    @Override public Void visit(StringLiteral stringLiteral) { return null; }
    @Override public Void visit(SpecifierQualifierList specifierQualifierList) { return null; }
    @Override public Void visit(SelectionStatement selectionStatement) { return null; }
    @Override public Void visit(IterationStatement iterationStatement) { return null; }
    @Override public Void visit(ForCondition forCondition) { return null; }
    @Override public Void visit(ForExpr forExpr) { return null; }
    @Override public Void visit(ForDeclaration forDeclaration) { return null; }
    @Override public Void visit(DesignationInitializerTuple designationInitializerTuple) { return null; }
    @Override public Void visit(InitializerList initializerList) { return null; }
    @Override public Void visit(Designation designation) { return null; }
    @Override public Void visit(Designator designator) { return null; }
    @Override public Void visit(JumpStatement jumpStatement) { return null; }
    @Override public Void visit(TypeName typeName) { return null; }
    @Override public Void visit(CompoundLiteralExpr compoundLiteralExpr) { return null; }
    @Override public Void visit(ArrayIndexingExpr arrayIndexingExpr) { return null; }
    @Override public Void visit(CastExpr castExpr) { return null; }
    @Override public Void visit(PrefixUnaryExpr prefixUnaryExpr) { return null; }
    @Override public Void visit(SizeOfExpr sizeOfExpr) { return null; }
    @Override public Void visit(TypeSpecifier typeSpecifier) { return null; }
    @Override public Void visit(DeclarationSpecifiers declarationSpecifiers) { return null; }
    @Override public Void visit(Declarator declarator) { return null; }
    @Override public Void visit(DeclarationList declarationList) { return null; }
    @Override public Void visit(Identifier identifier) { return null; }
} 