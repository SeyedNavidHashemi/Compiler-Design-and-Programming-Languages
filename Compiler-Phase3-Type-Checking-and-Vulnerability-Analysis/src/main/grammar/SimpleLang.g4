grammar SimpleLang;

@header {
    import main.ast.nodes.*;
    import main.ast.nodes.ExternalDeclaration.*;
    import main.ast.nodes.Expr.operator.*;
    import main.ast.nodes.Expr.*;
    import main.ast.nodes.Stmt.*;
    import main.ast.nodes.DirectDeclarator.*;
}

program returns [Program programRet]
    : { $programRet = new Program(); } (t = translationUnit{$programRet.setTranslationUnit($t.translationUnitRet); })? EOF ;

translationUnit returns [TranslationUnit translationUnitRet]
    : {$translationUnitRet = new TranslationUnit(); } (e=externalDeclaration{ $translationUnitRet.addExternalDeclaration($e.externalDeclarationRet); })+ ;

externalDeclaration returns [ExternalDeclaration externalDeclarationRet]
    : f=functionDefinition {$externalDeclarationRet = $f.funcDefExtDecRet;}
    | d4=declaration {$externalDeclarationRet = $d4.declarationRet;}
    | Semi ; // stray ;

functionDefinition returns [FuncDefExtDec funcDefExtDecRet]
    : {$funcDefExtDecRet = new FuncDefExtDec();}
    (d1=declarationSpecifiers{$funcDefExtDecRet.setDeclarationSpecifiers($d1.declarationSpecifiersRet);})?
     d2=declarator
        {
            $funcDefExtDecRet.setDeclarator($d2.declaratorRet);
            $funcDefExtDecRet.setLine($d2.declaratorRet.getLine());
        }
    (d3=declarationList{$funcDefExtDecRet.setDeclarationList($d3.declarationListRet);})?
     c=compoundStatement{$funcDefExtDecRet.setCompoundStatement($c.compoundStatementRet);};

declarationList returns [DeclarationList declarationListRet]
    : {$declarationListRet = new DeclarationList();}
    (d5=declaration{$declarationListRet.addDeclaration($d5.declarationRet);})+ ;

expression returns [Expr exprRet]
  : id=Identifier{$exprRet = new Identifier($id.text);$exprRet.setLine($id.line);}
  | co=Constant{$exprRet = new Constant($co.text);$exprRet.setLine($co.line);}
  | sl+=StringLiteral+ {
        StringBuilder sb = new StringBuilder();
        for (Token s : $sl) {
            sb.append(s.getText().substring(1, s.getText().length() - 1));
        }
        $exprRet = new StringLiteral(sb.toString());
    }

  | LeftParen e1=expression RightParen{$exprRet = $e1.exprRet;$exprRet.setLine($e1.exprRet.getLine());}
  | LeftParen tn1=typeName RightParen LeftBrace il2=initializerList Comma? RightBrace
    {
        $exprRet = new CompoundLiteralExpr($tn1.typeNameRet, $il2.initializerListRet);
        $exprRet.setLine($tn1.typeNameRet.getLine());
    }
  | e43=expression LeftBracket e44=expression RightBracket // Array indexing
    {
        $exprRet=new ArrayIndexingExpr($e43.exprRet, $e44.exprRet);
        $exprRet.setLine($e43.exprRet.getLine());
    }
  | e45=expression {FunctionCallExpr fce=new FunctionCallExpr($e45.exprRet);}
    LeftParen (ae=argumentExpressionList{fce.setArgumentExpressionList($ae.argumentExpressionListRet);})? RightParen // Function call
    {$exprRet=fce;$exprRet.setLine($e45.exprRet.getLine());}
  | e11=expression plpl=PlusPlus {$exprRet = new UnaryExpr($e11.exprRet, $plpl.text);}
  | e12=expression mnmn=MinusMinus {$exprRet = new UnaryExpr($e12.exprRet, $mnmn.text);}
  | {PrefixUnaryExpr pue = new PrefixUnaryExpr();}
    (plus=PlusPlus{pue.addPrefixOperator($plus.text);}
    | minus=MinusMinus{pue.addPrefixOperator($minus.text);}
    | sizeof=Sizeof{pue.addPrefixOperator($sizeof.text);})* (                                          // Prefix operators (zero or more)
         q1=Identifier{pue.setOperand(new Identifier($q1.text));}
       | q2=Constant{pue.setOperand(new Constant($q2.text));}
       | q3+=StringLiteral+{
                                   StringBuilder sb = new StringBuilder();
                                   for (Token s : $sl) {
                                       sb.append(s.getText().substring(1, s.getText().length() - 1));
                                   }
                                   pue.setOperand(new StringLiteral(sb.toString()));
                               }
       | LeftParen q4=expression RightParen {pue.setOperand($q4.exprRet);}
       | LeftParen tn2=typeName RightParen LeftBrace il3=initializerList Comma? RightBrace
       {pue.setOperand(new CompoundLiteralExpr($tn2.typeNameRet, $il3.initializerListRet));}
       | uo=unaryOperator ce1=castExpression {pue.setOperand(new UnaryExpr($ce1.exprRet, $uo.unaryOperatorRet));}
       | so=Sizeof LeftParen tn3=typeName RightParen{pue.setOperand(new SizeOfExpr($so.text, $tn3.typeNameRet));}
    )
    {$exprRet = pue;}
  | LeftParen tn4=typeName RightParen e46=castExpression// Cast expression
    {$exprRet = new CastExpr($tn4.typeNameRet, $e46.exprRet);}
  | e13=expression op4=(Star | Div | Mod) e14=expression
       {
          String op = ($op4.text.equals("*")) ? "*" :
                              ($op4.text.equals("/")) ? "/" : "%";
          $exprRet = new BinaryExpr($e13.exprRet, op, $e14.exprRet);
       }
  | e15=expression op5=(Plus | Minus) e16=expression
         {
            String op = ($op5.text.equals("+")) ? "+" : "-";
            $exprRet = new BinaryExpr($e15.exprRet, op, $e16.exprRet);
            $exprRet.setLine($e15.exprRet.getLine());
         }
  | e17=expression op6=(LeftShift | RightShift) e18=expression
         {
            String op = ($op6.text.equals("<<")) ? "<<" : ">>";
            $exprRet = new BinaryExpr($e17.exprRet, op, $e18.exprRet);
            $exprRet.setLine($e17.exprRet.getLine());
         }
  | e19=expression op7=(Less | Greater | LessEqual | GreaterEqual) e20=expression
        {
           String op = ($op7.text.equals("<")) ? "<" :
                               ($op7.text.equals(">")) ? ">" :
                               ($op7.text.equals("<=")) ? "<=" : ">=";
           $exprRet = new BinaryExpr($e19.exprRet, op, $e20.exprRet);
           $exprRet.setLine($e19.exprRet.getLine());
        }
  | e21=expression op8=(Equal | NotEqual) e22=expression
         {
            String op = ($op8.text.equals("==")) ? "==" : "!=";
            $exprRet = new BinaryExpr($e21.exprRet, op, $e22.exprRet);
            $exprRet.setLine($e21.exprRet.getLine());
         }
  | e23=expression v1=And e24=expression {$exprRet = new BinaryExpr($e23.exprRet, $v1.text, $e24.exprRet);} // Bitwise AND
  | e25=expression v2=Xor e26=expression {$exprRet = new BinaryExpr($e25.exprRet, $v2.text, $e26.exprRet);}// Bitwise XOR
  | e27=expression v3=Or e28=expression {$exprRet = new BinaryExpr($e27.exprRet, $v3.text, $e28.exprRet);}// Bitwise OR
  | e29=expression v4=AndAnd e30=expression {$exprRet = new BinaryExpr($e29.exprRet, $v4.text, $e30.exprRet);}// Logical AND
  | e34=expression v5=OrOr e35=expression {$exprRet = new BinaryExpr($e34.exprRet, $v5.text, $e35.exprRet);}// Logical OR
  | e36=expression Question e37=expression Colon e38=expression {$exprRet = new TernaryExpr($e36.exprRet, $e37.exprRet, $e38.exprRet);} // Conditional operator
  | e39=expression op14=assignmentOperator e40=expression {$exprRet = new AssignmentExpr($e39.exprRet, $op14.assignmentOperatorRet, $e40.exprRet);$exprRet.setLine($e39.exprRet.getLine());}// Assignment
  | e41=expression {$exprRet = new CommaExpr($e41.exprRet);$exprRet.setLine($e41.exprRet.getLine());} (Comma e42=expression {((CommaExpr) $exprRet).addExpr($e42.exprRet);})+;                                              // Comma operator

argumentExpressionList returns [CommaExpr argumentExpressionListRet]
  : e48=expression{CommaExpr nce = new CommaExpr($e48.exprRet);}(Comma e49=expression{nce.addExpr($e49.exprRet);})*
   {$argumentExpressionListRet = nce;};

unaryOperator returns [String unaryOperatorRet]
  : z1=And {$unaryOperatorRet=$z1.text;}
  | z2=Star {$unaryOperatorRet=$z2.text;}
  | z3=Plus {$unaryOperatorRet=$z3.text;}
  | z4=Minus {$unaryOperatorRet=$z4.text;}
  | z5=Tilde {$unaryOperatorRet=$z5.text;}
  | z6=Not {$unaryOperatorRet=$z6.text;};

castExpression returns [Expr exprRet]
  : LeftParen tn5=typeName RightParen ce=castExpression {$exprRet = new CastExpr($tn5.typeNameRet, $ce.exprRet);}
   | e47=expression {$exprRet = $e47.exprRet;}
   | dg=DigitSequence {$exprRet = new Constant($dg.text);};

assignmentOperator returns [String assignmentOperatorRet]
  : x1=Assign {$assignmentOperatorRet=$x1.text;}
  | x2=StarAssign {$assignmentOperatorRet=$x2.text;}
  | x3=DivAssign {$assignmentOperatorRet=$x3.text;}
  | x4=ModAssign {$assignmentOperatorRet=$x4.text;}
  | x5=PlusAssign {$assignmentOperatorRet=$x5.text;}
  | x6=MinusAssign {$assignmentOperatorRet=$x6.text;}
  | x7=LeftShiftAssign {$assignmentOperatorRet=$x7.text;}
  | x8=RightShiftAssign {$assignmentOperatorRet=$x8.text;}
  | x9=AndAssign {$assignmentOperatorRet=$x9.text;}
  | x10=XorAssign {$assignmentOperatorRet=$x10.text;}
  | x11=OrAssign {$assignmentOperatorRet=$x11.text;};

declaration returns [DecExtDec declarationRet]
   :dss=declarationSpecifiers  {$declarationRet = new DecExtDec($dss.declarationSpecifiersRet);$declarationRet.setLine($dss.declarationSpecifiersRet.getLine());}
   (idlt=initDeclaratorList{$declarationRet.setInitDeclaratorList($idlt.initDeclaratorListRet);})? Semi ;

declarationSpecifiers returns [DeclarationSpecifiers declarationSpecifiersRet]
    :{$declarationSpecifiersRet = new DeclarationSpecifiers();}
    (desSpec = declarationSpecifier{$declarationSpecifiersRet.addDeclarationSpecifier($desSpec.declarationSpecifierRet);
                                    $declarationSpecifiersRet.setLine($desSpec.declarationSpecifierRet.getLine());})+;
//    {$declarationSpecifiersRet.setVarDecItem();};

declarationSpecifier returns [DeclarationSpecifier declarationSpecifierRet]
    : t=Typedef {$declarationSpecifierRet = new DeclarationSpecifier($t.getText());$declarationSpecifierRet.setLine($t.line);}
    | ts=typeSpecifier {$declarationSpecifierRet = new DeclarationSpecifier($ts.typeSpecifierRet.getType()); $declarationSpecifierRet.setLine($ts.typeSpecifierRet.getLine());}
    | c1=Const {$declarationSpecifierRet = new DeclarationSpecifier($c1.getText());$declarationSpecifierRet.setLine($c1.line);};

initDeclaratorList returns [InitDeclaratorList initDeclaratorListRet]
    : id3=initDeclarator{$initDeclaratorListRet = new InitDeclaratorList($id3.initDeclaratorRet);}
    (Comma id4=initDeclarator{$initDeclaratorListRet.addInitDeclarator($id4.initDeclaratorRet);})* ;

initDeclarator returns [InitDeclarator initDeclaratorRet]
    : d11=declarator{$initDeclaratorRet = new InitDeclarator($d11.declaratorRet);}
    (Assign i=initializer{$initDeclaratorRet.setInitializer($i.initializerRet);})? ;

typeSpecifier returns [TypeSpecifier typeSpecifierRet]
    : vo=Void {$typeSpecifierRet = new TypeSpecifier($vo.text, $vo.line);}
    | ch=Char {$typeSpecifierRet = new TypeSpecifier($ch.text, $ch.line);}
    | sh=Short {$typeSpecifierRet = new TypeSpecifier($sh.text, $sh.line);}
    | in=Int {$typeSpecifierRet = new TypeSpecifier($in.text, $in.line);}
    | lo=Long {$typeSpecifierRet = new TypeSpecifier($lo.text, $lo.line);}
    | fl=Float {$typeSpecifierRet = new TypeSpecifier($fl.text, $fl.line);}
    | dob=Double {$typeSpecifierRet = new TypeSpecifier($dob.text, $dob.line);}
    | si=Signed {$typeSpecifierRet = new TypeSpecifier($si.text, $si.line);}
    | un=Unsigned {$typeSpecifierRet = new TypeSpecifier($un.text, $un.line);}
    | bo=Bool {$typeSpecifierRet = new TypeSpecifier($bo.text, $bo.line);}
    | ide1=Identifier {$typeSpecifierRet = new TypeSpecifier($ide1.text, $ide1.line);};

specifierQualifierList returns [SpecifierQualifierList specifierQualifierListRet]
    : {$specifierQualifierListRet = new SpecifierQualifierList();}
    (typeS=typeSpecifier{$specifierQualifierListRet.setTypeSpecifier($typeS.typeSpecifierRet);} | Const) specifierQualifierList? ;

declarator returns [Declarator declaratorRet]
    :{$declaratorRet = new Declarator();}
     (p1=pointer{$declaratorRet.setPointer($p1.pointerRet);})?
     d6=directDeclarator
        {
            $declaratorRet.setDirectDeclarator($d6.directDeclaratorRet);
            $declaratorRet.setLine($d6.directDeclaratorRet.getLine());
        };

directDeclarator returns [DirectDeclarator directDeclaratorRet]
    : ide2=Identifier
        {
            $directDeclaratorRet = new IdentifierDeclarator($ide2.text);
            $directDeclaratorRet.setLine($ide2.line);
        }
    | LeftParen inner_dec=declarator RightParen {$directDeclaratorRet = new NestedDeclarator($inner_dec.declaratorRet);}
    | dir1=directDeclarator{ArrayDeclarator ad = new ArrayDeclarator($dir1.directDeclaratorRet);}
     LeftBracket (e31=expression{ad.setExpr($e31.exprRet);})? RightBracket
     {$directDeclaratorRet = ad;}
    | dir2=directDeclarator {FunctionDeclarator fd = new FunctionDeclarator($dir2.directDeclaratorRet);}
     LeftParen  ((pl=parameterList{fd.setParameterList($pl.parameterListRet);fd.setIsOldStyle(false);})?
                | (il=identifierList{fd.setIdentifierList($il.identifierListRet);fd.setIsOldStyle(true);})?) RightParen
        {
            $directDeclaratorRet = fd;
            $directDeclaratorRet.setLine($dir2.directDeclaratorRet.getLine());
        }
    ;


pointer returns [Pointer pointerRet]
    : {$pointerRet = new Pointer(); Token lastStar = null;}
      ((s=Star {
            // mark where this * started
            lastStar = $s;
        }
        (Const+)? {
            // get the index range between this * and the next
            int from = lastStar.getTokenIndex() + 1;
            int to = _input.LT(1).getTokenIndex(); // next token to be matched (or EOF)

            boolean isConst = false;
            for (int i = from; i < to; i++) {
                Token t = _input.get(i);
                if (t.getType() == Const) {
                    isConst = true;
                    break;
                }
            }

            $pointerRet.addPointerLevel(new PointerLevel(isConst));
        })
      )+
    ;

parameterList returns [ParameterList parameterListRet]
    :{$parameterListRet = new ParameterList();}
    par1=parameterDeclaration {$parameterListRet.addParameter($par1.parameterDeclarationRet);}
    (Comma par2=parameterDeclaration{$parameterListRet.addParameter($par2.parameterDeclarationRet);})* ;

parameterDeclaration returns [ParameterDeclaration parameterDeclarationRet]
    : ds1=declarationSpecifiers{ParameterDeclaration pd = new ParameterDeclaration($ds1.declarationSpecifiersRet);}
     ((d=declarator{pd.setDeclarator($d.declaratorRet);})?
     | (a=abstractDeclarator{pd.setAbstractDeclarator($a.abstractDeclaratorRet);})?)
     {$parameterDeclarationRet = pd;};

identifierList returns [IdentifierList identifierListRet]
    : id1=Identifier {$identifierListRet = new IdentifierList(new Identifier($id1.text));}
     (Comma id2=Identifier{$identifierListRet.addIdentifier(new Identifier($id2.text));})* ;

typeName returns [TypeName typeNameRet]
    : sq=specifierQualifierList{$typeNameRet = new TypeName($sq.specifierQualifierListRet);}
     (ab=abstractDeclarator{$typeNameRet.setAbstractDeclarator($ab.abstractDeclaratorRet);})? ;

abstractDeclarator returns [AbstractDeclarator abstractDeclaratorRet]
    : {$abstractDeclaratorRet = new AbstractDeclarator();}
    p2=pointer{$abstractDeclaratorRet.setPointer($p2.pointerRet);}
    | (p3=pointer{$abstractDeclaratorRet.setPointer($p3.pointerRet);})?
    d8=directAbstractDeclarator{$abstractDeclaratorRet.setDirectAbstractDeclarator($d8.directAbstractDeclaratorRet);};

directAbstractDeclarator returns [DirectAbstractDeclarator directAbstractDeclaratorRet]
    :{$directAbstractDeclaratorRet = new DirectAbstractDeclarator();}
    LeftBracket (e32=expression{$directAbstractDeclaratorRet.setExpr($e32.exprRet);})? RightBracket
        {
            $directAbstractDeclaratorRet.setType(0);
        }
    | LeftParen  ((a1=abstractDeclarator{$directAbstractDeclaratorRet.setType(2);
                                        $directAbstractDeclaratorRet.setAbstractDeclarator($a1.abstractDeclaratorRet);})?
                 | (p4=parameterList{$directAbstractDeclaratorRet.setType(1);
                                    $directAbstractDeclaratorRet.setParameterList($p4.parameterListRet);})?) RightParen
    | d9=directAbstractDeclarator{$directAbstractDeclaratorRet.setNext($d9.directAbstractDeclaratorRet);}
    LeftBracket (e33=expression{$directAbstractDeclaratorRet.setExpr($e33.exprRet);})? RightBracket
        {
            $directAbstractDeclaratorRet.setType(0);
        }
    | d10=directAbstractDeclarator{$directAbstractDeclaratorRet.setNext($d10.directAbstractDeclaratorRet);}
     LeftParen (p5=parameterList{$directAbstractDeclaratorRet.setParameterList($p5.parameterListRet);})? RightParen
        {
            $directAbstractDeclaratorRet.setType(1);
        }
     ;

initializer returns [Initializer initializerRet]
    :{$initializerRet = new Initializer();}
    e8=expression {$initializerRet.setExpr($e8.exprRet);}
    | LeftBrace il1=initializerList Comma? RightBrace{$initializerRet.setInitializerList($il1.initializerListRet);};

initializerList returns [InitializerList initializerListRet]
    : {$initializerListRet = new InitializerList();}
    {DesignationInitializerTuple tuple = new DesignationInitializerTuple();}
    (d12=designation{tuple.setDesignation($d12.designationRet);})? i1=initializer{tuple.setInitializer($i1.initializerRet);}
        {
            $initializerListRet.addInitializer(tuple);
        }

    ({DesignationInitializerTuple tuple1 = new DesignationInitializerTuple();}Comma
    (d13=designation{tuple1.setDesignation($d13.designationRet);})?
     i2=initializer{tuple1.setInitializer($i2.initializerRet);}
     {$initializerListRet.addInitializer(tuple1);})* ;

designation returns [Designation designationRet]
    :{$designationRet = new Designation();} (d14=designator{$designationRet.addDesignator($d14.designatorRet);})+ Assign ;

designator returns [Designator designatorRet]
    :{$designatorRet = new Designator();}
    LeftBracket e9=expression {$designatorRet.setExpr($e9.exprRet);}RightBracket
    | Dot id5=Identifier {$designatorRet.setFieldName($id5.text);};

statement returns [Stmt stmtRet]
    : cs=compoundStatement{$stmtRet = $cs.compoundStatementRet;}
    | es=expressionStatement {$stmtRet = $es.expressionStatementRet;}
    | ss=selectionStatement {$stmtRet = $ss.selectionStatementRet;}
    | is=iterationStatement {$stmtRet = $is.iterationStatementRet;}
    | js=jumpStatement {$stmtRet = $js.jumpStatementRet;};

compoundStatement returns [CompoundStatement compoundStatementRet]
    :{$compoundStatementRet = new CompoundStatement();}
    LeftBrace (bi=blockItem{$compoundStatementRet.addBlockItem($bi.blockItemRet);})* RightBrace ;

blockItem returns [BlockItem blockItemRet]
    :s1=statement{$blockItemRet = new BlockItem();$blockItemRet.setStatement($s1.stmtRet);}
    | d7=declaration{$blockItemRet = new BlockItem();$blockItemRet.setDeclaration($d7.declarationRet);};

expressionStatement returns [ExpressionStatement expressionStatementRet]
    :{$expressionStatementRet = new ExpressionStatement();}
    (e1=expression{$expressionStatementRet.setExpr($e1.exprRet);$expressionStatementRet.setLine($e1.exprRet.getLine());})? Semi ;

selectionStatement returns [SelectionStatement selectionStatementRet]
    :{$selectionStatementRet = new SelectionStatement();}
    if1=If LeftParen e2=expression
        {
            $selectionStatementRet.setCondition($e2.exprRet);
        }
     RightParen
    s2=statement{$selectionStatementRet.setThenStmt($s2.stmtRet);}

    (Else If LeftParen explif=expression{$selectionStatementRet.addElseIfConditions($explif.exprRet);}
     RightParen stmelif=statement{$selectionStatementRet.addElseIfThenStmts($stmelif.stmtRet);})*

    (el=Else s3=statement{$selectionStatementRet.setElseStmt($s3.stmtRet);$selectionStatementRet.setElseLine($el.line);})? ;

iterationStatement returns [IterationStatement iterationStatementRet]
    :{$iterationStatementRet = new IterationStatement();}(
    wl=While LeftParen e3=expression RightParen s4=statement
        {
            $iterationStatementRet.setCondition($e3.exprRet);
            $iterationStatementRet.setStatement($s4.stmtRet);
            $iterationStatementRet.setType($wl.text);
            $iterationStatementRet.setLine($wl.line);
        }
    | do1=Do s5=statement wl1=While LeftParen e4=expression RightParen Semi
        {
             $iterationStatementRet.setCondition($e4.exprRet);
             $iterationStatementRet.setStatement($s5.stmtRet);
             $iterationStatementRet.setType($wl1.text);
             $iterationStatementRet.setLine($do1.line);
        }
    | fr=For LeftParen fc=forCondition RightParen s6=statement
        {
            $iterationStatementRet.setForCondition($fc.forConditionRet);
            $iterationStatementRet.setStatement($s6.stmtRet);
            $iterationStatementRet.setType($fr.text);
            $iterationStatementRet.setLine($fr.line);
        })
    ;

forCondition returns [ForCondition forConditionRet]
    :{$forConditionRet = new ForCondition();}
    ((fd1=forDeclaration{$forConditionRet.setForDeclaration($fd1.forDeclarationRet);})? | (e5=expression{$forConditionRet.setInitExpression($e5.exprRet);})?)
    Semi (fe=forExpression{$forConditionRet.setConditionExpression($fe.forExpressionRet);})?
    Semi (fe1=forExpression{$forConditionRet.setUpdateExpression($fe1.forExpressionRet);})?;



forDeclaration returns [ForDeclaration forDeclarationRet]
    : ds=declarationSpecifiers{$forDeclarationRet = new ForDeclaration($ds.declarationSpecifiersRet);}
     (idl=initDeclaratorList{$forDeclarationRet.setInitDeclaratorList($idl.initDeclaratorListRet);})? ;

forExpression returns [ForExpr forExpressionRet]
    : e6=expression{$forExpressionRet = new ForExpr($e6.exprRet);} (Comma e7=expression{$forExpressionRet.addExpr($e7.exprRet);})* ;

jumpStatement returns [JumpStatement jumpStatementRet]
    :{$jumpStatementRet = new JumpStatement();}
     ( con=Continue{$jumpStatementRet.setJumpType($con.text);   $jumpStatementRet.setLine($con.line);}
     | bre=Break{$jumpStatementRet.setJumpType($bre.text);  $jumpStatementRet.setLine($bre.line);}
     | ret=Return {$jumpStatementRet.setJumpType($ret.text);    $jumpStatementRet.setLine($ret.line);}(e10=expression{$jumpStatementRet.setReturnExpr($e10.exprRet);})? ) Semi ;

Break                 : 'break'                 ;
Char                  : 'char'                  ;
Const                 : 'const'                 ;
Continue              : 'continue'              ;
Do                    : 'do'                    ;
Double                : 'double'                ;
Else                  : 'else'                  ;
Float                 : 'float'                 ;
For                   : 'for'                   ;
If                    : 'if'                    ;
Int                   : 'int'                   ;
Long                  : 'long'                  ;
Return                : 'return'                ;
Short                 : 'short'                 ;
Signed                : 'signed'                ;
Sizeof                : 'sizeof'                ;
Switch                : 'switch'                ;
Typedef               : 'typedef'               ;
Unsigned              : 'unsigned'              ;
Void                  : 'void'                  ;
While                 : 'while'                 ;
Bool                  : 'bool'                  ;
LeftParen             : '('                     ;
RightParen            : ')'                     ;
LeftBracket           : '['                     ;
RightBracket          : ']'                     ;
LeftBrace             : '{'                     ;
RightBrace            : '}'                     ;
Less                  : '<'                     ;
LessEqual             : '<='                    ;
Greater               : '>'                     ;
GreaterEqual          : '>='                    ;
LeftShift             : '<<'                    ;
RightShift            : '>>'                    ;
Plus                  : '+'                     ;
PlusPlus              : '++'                    ;
Minus                 : '-'                     ;
MinusMinus            : '--'                    ;
Star                  : '*'                     ;
Div                   : '/'                     ;
Mod                   : '%'                     ;
And                   : '&'                     ;
Or                    : '|'                     ;
AndAnd                : '&&'                    ;
OrOr                  : '||'                    ;
Xor                   : '^'                     ;
Not                   : '!'                     ;
Tilde                 : '~'                     ;
Question              : '?'                     ;
Colon                 : ':'                     ;
Semi                  : ';'                     ;
Comma                 : ','                     ;
Assign                : '='                     ;
StarAssign            : '*='                    ;
DivAssign             : '/='                    ;
ModAssign             : '%='                    ;
PlusAssign            : '+='                    ;
MinusAssign           : '-='                    ;
LeftShiftAssign       : '<<='                   ;
RightShiftAssign      : '>>='                   ;
AndAssign             : '&='                    ;
XorAssign             : '^='                    ;
OrAssign              : '|='                    ;
Equal                 : '=='                    ;
NotEqual              : '!='                    ;
Arrow                 : '->'                    ;
Dot                   : '.'                     ;

Identifier
    : IdentifierNondigit (IdentifierNondigit | Digit)* ;

fragment IdentifierNondigit
    : Nondigit | UniversalCharacterName ;

fragment Nondigit
    : [a-zA-Z_] ;

fragment Digit
    : [0-9] ;

fragment UniversalCharacterName
    : '\\u' HexQuad | '\\U' HexQuad HexQuad ;

fragment HexQuad
    : HexadecimalDigit HexadecimalDigit HexadecimalDigit HexadecimalDigit ;

Constant
    : IntegerConstant | FloatingConstant | CharacterConstant ;

fragment IntegerConstant
    : DecimalConstant IntegerSuffix?
    | OctalConstant IntegerSuffix?
    | HexadecimalConstant IntegerSuffix?
    | BinaryConstant ;

fragment BinaryConstant
    : '0' [bB] [0-1]+ ;

fragment DecimalConstant
    : NonzeroDigit Digit* ;

fragment OctalConstant
    : '0' OctalDigit* ;

fragment HexadecimalConstant
    : HexadecimalPrefix HexadecimalDigit+ ;

fragment HexadecimalPrefix
    : '0' [xX] ;

fragment NonzeroDigit
    : [1-9] ;

fragment OctalDigit
    : [0-7] ;

fragment HexadecimalDigit
    : [0-9a-fA-F] ;

fragment IntegerSuffix
    : UnsignedSuffix LongSuffix? | UnsignedSuffix LongLongSuffix | LongSuffix UnsignedSuffix? | LongLongSuffix UnsignedSuffix? ;

fragment UnsignedSuffix
    : [uU] ;

fragment LongSuffix
    : [lL] ;

fragment LongLongSuffix
    : 'll' | 'LL' ;

fragment FloatingConstant
    : DecimalFloatingConstant | HexadecimalFloatingConstant ;

fragment DecimalFloatingConstant
    : FractionalConstant ExponentPart? FloatingSuffix? | DigitSequence ExponentPart FloatingSuffix? ;

fragment HexadecimalFloatingConstant
    : HexadecimalPrefix (HexadecimalFractionalConstant | HexadecimalDigitSequence) BinaryExponentPart FloatingSuffix? ;

fragment FractionalConstant
    : DigitSequence? Dot DigitSequence | DigitSequence Dot ;

fragment ExponentPart
    : [eE] Sign? DigitSequence ;

fragment Sign
    : [+-] ;

DigitSequence
    : Digit+ ;

fragment HexadecimalFractionalConstant
    : HexadecimalDigitSequence? Dot HexadecimalDigitSequence | HexadecimalDigitSequence Dot ;

fragment BinaryExponentPart
    : [pP] Sign? DigitSequence ;

fragment HexadecimalDigitSequence
    : HexadecimalDigit+ ;

fragment FloatingSuffix
    : [flFL] ;

fragment CharacterConstant
    : '\'' CCharSequence '\'' | 'L\'' CCharSequence '\''| 'u\'' CCharSequence '\'' | 'U\'' CCharSequence '\''
    ;

fragment CCharSequence
    : CChar+ ;

fragment CChar
    : ~['\\\r\n] | EscapeSequence ;

fragment EscapeSequence
    : SimpleEscapeSequence | OctalEscapeSequence | HexadecimalEscapeSequence | UniversalCharacterName ;

fragment SimpleEscapeSequence
    : '\\' ['"?abfnrtv\\] ;

fragment OctalEscapeSequence
    : '\\' OctalDigit OctalDigit? OctalDigit? ;

fragment HexadecimalEscapeSequence
    : '\\x' HexadecimalDigit+ ;

StringLiteral
    : EncodingPrefix? '"' SCharSequence? '"' ;

fragment EncodingPrefix
    : 'u8' | 'u' | 'U' | 'L' ;

fragment SCharSequence
    : SChar+ ;

fragment SChar
    : ~["\\\r\n] | EscapeSequence | '\\\n' | '\\\r\n' ;

MultiLineMacro
    : '#' (~[\n]*? '\\' '\r'? '\n')+ ~ [\n]+ -> channel(HIDDEN) ;

Directive
    : '#' ~[\n]* -> channel(HIDDEN) ;

Whitespace
    : [ \t]+ -> channel(HIDDEN) ;

Newline
    : ('\r' '\n'? | '\n') -> channel(HIDDEN) ;

BlockComment
    : '/*' .*? '*/' -> channel(HIDDEN) ;

LineComment
    : '//' ~[\r\n]* -> channel(HIDDEN) ;
